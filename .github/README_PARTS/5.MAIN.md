# üöÄ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ –∑–∞–ø—É—Å–∫

<h2 align="center">
  <a href="#-—Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ">‚¨ÜÔ∏è –ù–∞–≤–µ—Ä—Ö</a> 
</h2>

## 1. –°–∫–∞—á–∏–≤–∞–µ–º `Discord PTB` —Å –û–§–ò–¶–ò–ê–õ–¨–ù–û–ì–û –°–ï–†–í–ï–†–ê.

```sh
https://ptb.discord.com/
```
## 2. –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º `Discord PTB`

## 3. –ó–∞–ø—É—Å—Ç–∏—Ç–µ `Discord PTB`

<p align="center">
  <img src="./media/icon.png" alt="Discord PTB" width="100">
</p>

## 4. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ —Ä–∞–∑–¥–µ–ª `–ø—É—Ç–∏—à–µ—Å—Ç–≤–∏—è` –ø–æ—Ç–æ–º –≤–æ –≤–∫–ª–∞–¥–∫—É `–ó–∞–¥–∞–Ω–∏—è` (Quests)

## 5. –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞–Ω–∏–µ

<p align="center">
  <img src="./media/7-Automatic-Discord-tasks.png" alt="Automatic-Discord-tasks" width="400">
</p>

## 6. –ù–∞–∂–∏–º–∞–µ–º `Ctrl+Shift+I` —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –∫–æ–Ω—Å–æ–ª—å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞

## 7. –ö–æ–ø–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —Å–∫—Ä–∏–ø—Ç–∞

- [RU-Automatic-Discord-tasks](/RU-Automatic-Discord-tasks.md) –õ–æ–≥–∏ –≤ –∫–∞–Ω—Å–æ–ª–∏ –±—É–¥—É–Ω –Ω–∞ –†—É—Å—Å–∫–æ–º

<details>
    <summary> ‚öôÔ∏è –†–∞–∑–≤–µ—Ä–Ω–∏—Ç–µ –≤–Ω—É—Ç—Ä–∏ —Å–∫—Ä–∏–ø—Ç: RU-Automatic-Discord-tasks </summary>

```js
delete window.$;
let wpRequire = webpackChunkdiscord_app.push([[Symbol()], {}, r => r]);
webpackChunkdiscord_app.pop();

let ApplicationStreamingStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getStreamerActiveStreamMetadata)?.exports?.Z;
let RunningGameStore, QuestsStore, ChannelStore, GuildChannelStore, FluxDispatcher, api;
if (!ApplicationStreamingStore) {
    ApplicationStreamingStore = Object.values(wpRequire.c).find(x => x?.exports?.A?.__proto__?.getStreamerActiveStreamMetadata).exports.A;
    RunningGameStore = Object.values(wpRequire.c).find(x => x?.exports?.Ay?.getRunningGames).exports.Ay;
    QuestsStore = Object.values(wpRequire.c).find(x => x?.exports?.A?.__proto__?.getQuest).exports.A;
    ChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.A?.__proto__?.getAllThreadsForParent).exports.A;
    GuildChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.Ay?.getSFWDefaultChannel).exports.Ay;
    FluxDispatcher = Object.values(wpRequire.c).find(x => x?.exports?.h?.__proto__?.flushWaitQueue).exports.h;
    api = Object.values(wpRequire.c).find(x => x?.exports?.Bo?.get).exports.Bo;
} else {
    RunningGameStore = Object.values(wpRequire.c).find(x => x?.exports?.ZP?.getRunningGames).exports.ZP;
    QuestsStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getQuest).exports.Z;
    ChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getAllThreadsForParent).exports.Z;
    GuildChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.ZP?.getSFWDefaultChannel).exports.ZP;
    FluxDispatcher = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.flushWaitQueue).exports.Z;
    api = Object.values(wpRequire.c).find(x => x?.exports?.tn?.get).exports.tn;
}

const supportedTasks = ["WATCH_VIDEO", "PLAY_ON_DESKTOP", "STREAM_ON_DESKTOP", "PLAY_ACTIVITY", "WATCH_VIDEO_ON_MOBILE"];
let quests = [...QuestsStore.quests.values()].filter(x => 
    x.userStatus?.enrolledAt && 
    !x.userStatus?.completedAt && 
    new Date(x.config.expiresAt).getTime() > Date.now() && 
    supportedTasks.find(y => Object.keys((x.config.taskConfig ?? x.config.taskConfigV2).tasks || {}).includes(y))
);
let isApp = typeof DiscordNative !== "undefined";

const log = (msg, color = '#fff') => console.log(`%c${msg}`, `color: ${color}; font-family: Consolas, monospace;`);
const success = (msg) => log(`[SUCCESS] ${msg}`, '#00ff9d');
const info = (msg) => log(`[INFO]    ${msg}`, '#4da6ff');
const warn = (msg) => log(`[WARN]    ${msg}`, '#ffcc00');
const error = (msg) => log(`[ERROR]   ${msg}`, '#ff4d4d');

function progressBar(progress, total, width = 20) {
  const percent = Math.min(100, Math.floor((progress / total) * 100));
  const filled = Math.floor((width * progress) / total);
  const bar = '‚ñà'.repeat(filled) + '‚ñë'.repeat(width - filled);
  const timeLeft = Math.ceil((total - progress) / 60);
  return `[${bar}] ${progress}/${total} (${percent}%) ‚Ä¢ ${timeLeft} min left`;
}

if (quests.length === 0) {
  info("No active supported quests found. Check Discover ‚Üí Quests.");
} else {
  console.groupCollapsed('%cüéÆ Discord Quest Booster v2.1 ‚Äì Active Tasks üöÄ', 'color:#7289da; font-weight:bold; font-size:14px;');
  log(`Found ${quests.length} quest(s)`, '#7289da');
  quests.forEach((q, i) => {
    const task = Object.keys(q.config.taskConfig?.tasks || q.config.taskConfigV2.tasks || {})[0];
    const target = q.config.taskConfig?.tasks?.[task]?.target || 'unknown';
    log(`\nQuest ${i+1}: ${q.config.messages.questName} (${task})`, '#ffffff');
    log(`  Target: ${target} sec`, '#cccccc');
    log(`  Remaining: ~${Math.ceil((target - (q.userStatus?.progress?.[task]?.value || 0)) / 60)} min`, '#cccccc');
  });
  console.groupEnd();

  let doJob = function() {
    const quest = quests.pop();
    if (!quest) {
      console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color:#7289da');
      success('All supported quests completed! Enjoy your rewards ‚ú®');
      console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color:#7289da');
      return;
    }

    const pid = Math.floor(Math.random() * 30000) + 1000;
    const applicationId = quest.config.application.id;
    const applicationName = quest.config.application.name;
    const questName = quest.config.messages.questName;
    const taskConfig = quest.config.taskConfig ?? quest.config.taskConfigV2;
    const taskName = supportedTasks.find(x => taskConfig.tasks?.[x] != null);
    
    if (!taskName) {
      error(`No supported task found in quest ${questName}. Skipping...`);
      doJob();
      return;
    }

    let secondsNeeded;
    try {
      secondsNeeded = taskConfig.tasks[taskName]?.target ?? 
                      taskConfig.tasks[taskName]?.durationSeconds ?? 
                      taskConfig.tasks[taskName]?.goal ?? 
                      900;
      if (!secondsNeeded || isNaN(secondsNeeded)) {
        warn(`Target not found for ${questName}! Using fallback 900 sec.`);
        secondsNeeded = 900;
      }
    } catch (e) {
      error(`Error reading target for ${questName}: ${e.message}`);
      secondsNeeded = 900;
    }

    let secondsDone = quest.userStatus?.progress?.[taskName]?.value ?? 
                      quest.userStatus?.progress?.[taskName]?.progress ?? 0;

    info(`Starting quest: ${questName} (${taskName}) | Detected target: ${secondsNeeded} sec | Done: ${secondsDone} sec`);

    if (taskName === "WATCH_VIDEO" || taskName === "WATCH_VIDEO_ON_MOBILE") {
      const maxFuture = 10, speed = 7, interval = 1;
      const enrolledAt = new Date(quest.userStatus.enrolledAt).getTime();
      let completed = false;
      let fn = async () => {
        while (true) {
          const maxAllowed = Math.floor((Date.now() - enrolledAt)/1000) + maxFuture;
          const diff = maxAllowed - secondsDone;
          const timestamp = secondsDone + speed;
          if (diff >= speed) {
            const res = await api.post({url: `/quests/${quest.id}/video-progress`, body: {timestamp: Math.min(secondsNeeded, timestamp + Math.random())}});
            completed = res.body.completed_at != null;
            secondsDone = Math.min(secondsNeeded, timestamp);
            const progText = progressBar(secondsDone, secondsNeeded);
            log(`Video spoof: ${progText}`, '#00ff9d');
          }
          
          if (timestamp >= secondsNeeded) {
            break;
          }
          await new Promise(resolve => setTimeout(resolve, interval * 1000));
        }
        if (!completed) {
          await api.post({url: `/quests/${quest.id}/video-progress`, body: {timestamp: secondsNeeded}});
        }
        success(`Quest completed: ${questName} üéâ`);
        doJob();
      };
      fn();
      info(`Spoofing video for ${questName}.`);
    } else if (taskName === "PLAY_ON_DESKTOP") {
      if (!isApp) {
        warn("This no longer works in browser for non-video quests. Use the discord desktop app.");
        doJob();
        return;
      }
      api.get({url: `/applications/public?application_ids=${applicationId}`}).then(res => {
        const appData = res.body[0];
        const exeName = appData.executables.find(x => x.os === "win32")?.name?.replace(">","") || "game.exe";
        
        const fakeGame = {
          cmdLine: `C:\\Program Files\\${appData.name}\\${exeName}`,
          exeName,
          exePath: `c:/program files/${appData.name.toLowerCase()}/${exeName}`,
          hidden: false,
          isLauncher: false,
          id: applicationId,
          name: appData.name,
          pid: pid,
          pidPath: [pid],
          processName: appData.name,
          start: Date.now(),
        };
        const realGames = RunningGameStore.getRunningGames();
        const fakeGames = [fakeGame];
        const realGetRunningGames = RunningGameStore.getRunningGames;
        const realGetGameForPID = RunningGameStore.getGameForPID;
        RunningGameStore.getRunningGames = () => fakeGames;
        RunningGameStore.getGameForPID = (pid) => fakeGames.find(x => x.pid === pid);
        FluxDispatcher.dispatch({type: "RUNNING_GAMES_CHANGE", removed: realGames, added: [fakeGame], games: fakeGames});
        
        let fn = data => {
          let progress = quest.config.configVersion === 1 ? data.userStatus.streamProgressSeconds : Math.floor(data.userStatus.progress.PLAY_ON_DESKTOP.value || 0);
          const progText = progressBar(progress, secondsNeeded);
          const percent = Math.round((progress / secondsNeeded) * 100);
          const color = percent >= 90 ? '#00ff9d' : percent >= 50 ? '#ffcc00' : '#4da6ff';
          log(`Progress: ${progText}`, color);
          
          if (progress >= secondsNeeded) {
            success(`Quest completed: ${questName} üéâ`);
            
            RunningGameStore.getRunningGames = realGetRunningGames;
            RunningGameStore.getGameForPID = realGetGameForPID;
            FluxDispatcher.dispatch({type: "RUNNING_GAMES_CHANGE", removed: [fakeGame], added: [], games: []});
            FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
            
            doJob();
          }
        };
        FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
        
        info(`Spoofed your game to ${applicationName}. Wait for ${Math.ceil((secondsNeeded - secondsDone) / 60)} more minutes.`);
      }).catch(e => {
        error(`API error for ${questName}: ${e.message}`);
        doJob();
      });
    } else if (taskName === "STREAM_ON_DESKTOP") {
      if (!isApp) {
        warn("This no longer works in browser for non-video quests. Use the discord desktop app.");
        doJob();
        return;
      }
      let realFunc = ApplicationStreamingStore.getStreamerActiveStreamMetadata;
      ApplicationStreamingStore.getStreamerActiveStreamMetadata = () => ({
        id: applicationId,
        pid,
        sourceName: null
      });
      
      let fn = data => {
        let progress = quest.config.configVersion === 1 ? data.userStatus.streamProgressSeconds : Math.floor(data.userStatus.progress.STREAM_ON_DESKTOP.value || 0);
        const progText = progressBar(progress, secondsNeeded);
        const percent = Math.round((progress / secondsNeeded) * 100);
        const color = percent >= 90 ? '#00ff9d' : percent >= 50 ? '#ffcc00' : '#4da6ff';
        log(`Progress: ${progText}`, color);
        
        if (progress >= secondsNeeded) {
          success(`Quest completed: ${questName} üéâ`);
          
          ApplicationStreamingStore.getStreamerActiveStreamMetadata = realFunc;
          FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
          
          doJob();
        }
      };
      FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
      
      info(`Spoofed your stream to ${applicationName}. Stream any window in vc for ${Math.ceil((secondsNeeded - secondsDone) / 60)} more minutes.`);
      warn("Remember that you need at least 1 other person to be in the vc!");
    } else if (taskName === "PLAY_ACTIVITY") {
      const channelId = ChannelStore.getSortedPrivateChannels()[0]?.id ?? Object.values(GuildChannelStore.getAllGuilds()).find(x => x != null && x.VOCAL.length > 0)?.VOCAL[0]?.channel.id;
      const streamKey = `call:${channelId}:1`;
      
      let fn = async () => {
        info(`Completing quest ${questName}`);
        
        while (true) {
          const res = await api.post({url: `/quests/${quest.id}/heartbeat`, body: {stream_key: streamKey, terminal: false}});
          const progress = res.body.progress.PLAY_ACTIVITY.value || 0;
          const progText = progressBar(progress, secondsNeeded);
          const percent = Math.round((progress / secondsNeeded) * 100);
          const color = percent >= 90 ? '#00ff9d' : percent >= 50 ? '#ffcc00' : '#4da6ff';
          log(`Progress: ${progText}`, color);
          
          await new Promise(resolve => setTimeout(resolve, 20 * 1000));
          
          if (progress >= secondsNeeded) {
            await api.post({url: `/quests/${quest.id}/heartbeat`, body: {stream_key: streamKey, terminal: true}});
            break;
          }
        }
        
        success(`Quest completed: ${questName} üéâ`);
        doJob();
      };
      fn();
    }
  };
  doJob();
}

```

</details>

–∏–ª–∏

- [EN-Automatic-Discord-tasks](/EN-Automatic-Discord-tasks.md) –õ–æ–≥–∏ –≤ –∫–∞–Ω—Å–æ–ª–∏ –±—É–¥—É–Ω –Ω–∞ –ê–Ω–≥–ª–∏–π—Å–∫–æ–º

<details>
    <summary> ‚öôÔ∏è –†–∞–∑–≤–µ—Ä–Ω–∏—Ç–µ –≤–Ω—É—Ç—Ä–∏ —Å–∫—Ä–∏–ø—Ç: EN-Automatic-Discord-tasks </summary>

```js
delete window.$;
let wpRequire = webpackChunkdiscord_app.push([[Symbol()], {}, r => r]);
webpackChunkdiscord_app.pop();

let ApplicationStreamingStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getStreamerActiveStreamMetadata)?.exports?.Z;
let RunningGameStore, QuestsStore, ChannelStore, GuildChannelStore, FluxDispatcher, api;
if (!ApplicationStreamingStore) {
    ApplicationStreamingStore = Object.values(wpRequire.c).find(x => x?.exports?.A?.__proto__?.getStreamerActiveStreamMetadata).exports.A;
    RunningGameStore = Object.values(wpRequire.c).find(x => x?.exports?.Ay?.getRunningGames).exports.Ay;
    QuestsStore = Object.values(wpRequire.c).find(x => x?.exports?.A?.__proto__?.getQuest).exports.A;
    ChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.A?.__proto__?.getAllThreadsForParent).exports.A;
    GuildChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.Ay?.getSFWDefaultChannel).exports.Ay;
    FluxDispatcher = Object.values(wpRequire.c).find(x => x?.exports?.h?.__proto__?.flushWaitQueue).exports.h;
    api = Object.values(wpRequire.c).find(x => x?.exports?.Bo?.get).exports.Bo;
} else {
    RunningGameStore = Object.values(wpRequire.c).find(x => x?.exports?.ZP?.getRunningGames).exports.ZP;
    QuestsStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getQuest).exports.Z;
    ChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getAllThreadsForParent).exports.Z;
    GuildChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.ZP?.getSFWDefaultChannel).exports.ZP;
    FluxDispatcher = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.flushWaitQueue).exports.Z;
    api = Object.values(wpRequire.c).find(x => x?.exports?.tn?.get).exports.tn;
}

const supportedTasks = ["WATCH_VIDEO", "PLAY_ON_DESKTOP", "STREAM_ON_DESKTOP", "PLAY_ACTIVITY", "WATCH_VIDEO_ON_MOBILE"];
let quests = [...QuestsStore.quests.values()].filter(x => 
    x.userStatus?.enrolledAt && 
    !x.userStatus?.completedAt && 
    new Date(x.config.expiresAt).getTime() > Date.now() && 
    supportedTasks.find(y => Object.keys((x.config.taskConfig ?? x.config.taskConfigV2).tasks || {}).includes(y))
);
let isApp = typeof DiscordNative !== "undefined";

const log = (msg, color = '#fff') => console.log(`%c${msg}`, `color: ${color}; font-family: Consolas, monospace;`);
const success = (msg) => log(`[SUCCESS] ${msg}`, '#00ff9d');
const info = (msg) => log(`[INFO]    ${msg}`, '#4da6ff');
const warn = (msg) => log(`[WARN]    ${msg}`, '#ffcc00');
const error = (msg) => log(`[ERROR]   ${msg}`, '#ff4d4d');

function progressBar(progress, total, width = 20) {
  const percent = Math.min(100, Math.floor((progress / total) * 100));
  const filled = Math.floor((width * progress) / total);
  const bar = '‚ñà'.repeat(filled) + '‚ñë'.repeat(width - filled);
  const timeLeft = Math.ceil((total - progress) / 60);
  return `[${bar}] ${progress}/${total} (${percent}%) ‚Ä¢ ${timeLeft} min left`;
}

if (quests.length === 0) {
  info("No active supported quests found. Check Discover ‚Üí Quests.");
} else {
  console.groupCollapsed('%cüéÆ Discord Quest Booster v2.1 ‚Äì Active Tasks üöÄ', 'color:#7289da; font-weight:bold; font-size:14px;');
  log(`Found ${quests.length} quest(s)`, '#7289da');
  quests.forEach((q, i) => {
    const task = Object.keys(q.config.taskConfig?.tasks || q.config.taskConfigV2.tasks || {})[0];
    const target = q.config.taskConfig?.tasks?.[task]?.target || 'unknown';
    log(`\nQuest ${i+1}: ${q.config.messages.questName} (${task})`, '#ffffff');
    log(`  Target: ${target} sec`, '#cccccc');
    log(`  Remaining: ~${Math.ceil((target - (q.userStatus?.progress?.[task]?.value || 0)) / 60)} min`, '#cccccc');
  });
  console.groupEnd();

  let doJob = function() {
    const quest = quests.pop();
    if (!quest) {
      console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color:#7289da');
      success('All supported quests completed! Enjoy your rewards ‚ú®');
      console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color:#7289da');
      return;
    }

    const pid = Math.floor(Math.random() * 30000) + 1000;
    const applicationId = quest.config.application.id;
    const applicationName = quest.config.application.name;
    const questName = quest.config.messages.questName;
    const taskConfig = quest.config.taskConfig ?? quest.config.taskConfigV2;
    const taskName = supportedTasks.find(x => taskConfig.tasks?.[x] != null);
    
    if (!taskName) {
      error(`No supported task found in quest ${questName}. Skipping...`);
      doJob();
      return;
    }

    let secondsNeeded;
    try {
      secondsNeeded = taskConfig.tasks[taskName]?.target ?? 
                      taskConfig.tasks[taskName]?.durationSeconds ?? 
                      taskConfig.tasks[taskName]?.goal ?? 
                      900;
      if (!secondsNeeded || isNaN(secondsNeeded)) {
        warn(`Target not found for ${questName}! Using fallback 900 sec.`);
        secondsNeeded = 900;
      }
    } catch (e) {
      error(`Error reading target for ${questName}: ${e.message}`);
      secondsNeeded = 900;
    }

    let secondsDone = quest.userStatus?.progress?.[taskName]?.value ?? 
                      quest.userStatus?.progress?.[taskName]?.progress ?? 0;

    info(`Starting quest: ${questName} (${taskName}) | Detected target: ${secondsNeeded} sec | Done: ${secondsDone} sec`);

    if (taskName === "WATCH_VIDEO" || taskName === "WATCH_VIDEO_ON_MOBILE") {
      const maxFuture = 10, speed = 7, interval = 1;
      const enrolledAt = new Date(quest.userStatus.enrolledAt).getTime();
      let completed = false;
      let fn = async () => {
        while (true) {
          const maxAllowed = Math.floor((Date.now() - enrolledAt)/1000) + maxFuture;
          const diff = maxAllowed - secondsDone;
          const timestamp = secondsDone + speed;
          if (diff >= speed) {
            const res = await api.post({url: `/quests/${quest.id}/video-progress`, body: {timestamp: Math.min(secondsNeeded, timestamp + Math.random())}});
            completed = res.body.completed_at != null;
            secondsDone = Math.min(secondsNeeded, timestamp);
            const progText = progressBar(secondsDone, secondsNeeded);
            log(`Video spoof: ${progText}`, '#00ff9d');
          }
          
          if (timestamp >= secondsNeeded) {
            break;
          }
          await new Promise(resolve => setTimeout(resolve, interval * 1000));
        }
        if (!completed) {
          await api.post({url: `/quests/${quest.id}/video-progress`, body: {timestamp: secondsNeeded}});
        }
        success(`Quest completed: ${questName} üéâ`);
        doJob();
      };
      fn();
      info(`Spoofing video for ${questName}.`);
    } else if (taskName === "PLAY_ON_DESKTOP") {
      if (!isApp) {
        warn("This no longer works in browser for non-video quests. Use the discord desktop app.");
        doJob();
        return;
      }
      api.get({url: `/applications/public?application_ids=${applicationId}`}).then(res => {
        const appData = res.body[0];
        const exeName = appData.executables.find(x => x.os === "win32")?.name?.replace(">","") || "game.exe";
        
        const fakeGame = {
          cmdLine: `C:\\Program Files\\${appData.name}\\${exeName}`,
          exeName,
          exePath: `c:/program files/${appData.name.toLowerCase()}/${exeName}`,
          hidden: false,
          isLauncher: false,
          id: applicationId,
          name: appData.name,
          pid: pid,
          pidPath: [pid],
          processName: appData.name,
          start: Date.now(),
        };
        const realGames = RunningGameStore.getRunningGames();
        const fakeGames = [fakeGame];
        const realGetRunningGames = RunningGameStore.getRunningGames;
        const realGetGameForPID = RunningGameStore.getGameForPID;
        RunningGameStore.getRunningGames = () => fakeGames;
        RunningGameStore.getGameForPID = (pid) => fakeGames.find(x => x.pid === pid);
        FluxDispatcher.dispatch({type: "RUNNING_GAMES_CHANGE", removed: realGames, added: [fakeGame], games: fakeGames});
        
        let fn = data => {
          let progress = quest.config.configVersion === 1 ? data.userStatus.streamProgressSeconds : Math.floor(data.userStatus.progress.PLAY_ON_DESKTOP.value || 0);
          const progText = progressBar(progress, secondsNeeded);
          const percent = Math.round((progress / secondsNeeded) * 100);
          const color = percent >= 90 ? '#00ff9d' : percent >= 50 ? '#ffcc00' : '#4da6ff';
          log(`Progress: ${progText}`, color);
          
          if (progress >= secondsNeeded) {
            success(`Quest completed: ${questName} üéâ`);
            
            RunningGameStore.getRunningGames = realGetRunningGames;
            RunningGameStore.getGameForPID = realGetGameForPID;
            FluxDispatcher.dispatch({type: "RUNNING_GAMES_CHANGE", removed: [fakeGame], added: [], games: []});
            FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
            
            doJob();
          }
        };
        FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
        
        info(`Spoofed your game to ${applicationName}. Wait for ${Math.ceil((secondsNeeded - secondsDone) / 60)} more minutes.`);
      }).catch(e => {
        error(`API error for ${questName}: ${e.message}`);
        doJob();
      });
    } else if (taskName === "STREAM_ON_DESKTOP") {
      if (!isApp) {
        warn("This no longer works in browser for non-video quests. Use the discord desktop app.");
        doJob();
        return;
      }
      let realFunc = ApplicationStreamingStore.getStreamerActiveStreamMetadata;
      ApplicationStreamingStore.getStreamerActiveStreamMetadata = () => ({
        id: applicationId,
        pid,
        sourceName: null
      });
      
      let fn = data => {
        let progress = quest.config.configVersion === 1 ? data.userStatus.streamProgressSeconds : Math.floor(data.userStatus.progress.STREAM_ON_DESKTOP.value || 0);
        const progText = progressBar(progress, secondsNeeded);
        const percent = Math.round((progress / secondsNeeded) * 100);
        const color = percent >= 90 ? '#00ff9d' : percent >= 50 ? '#ffcc00' : '#4da6ff';
        log(`Progress: ${progText}`, color);
        
        if (progress >= secondsNeeded) {
          success(`Quest completed: ${questName} üéâ`);
          
          ApplicationStreamingStore.getStreamerActiveStreamMetadata = realFunc;
          FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
          
          doJob();
        }
      };
      FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
      
      info(`Spoofed your stream to ${applicationName}. Stream any window in vc for ${Math.ceil((secondsNeeded - secondsDone) / 60)} more minutes.`);
      warn("Remember that you need at least 1 other person to be in the vc!");
    } else if (taskName === "PLAY_ACTIVITY") {
      const channelId = ChannelStore.getSortedPrivateChannels()[0]?.id ?? Object.values(GuildChannelStore.getAllGuilds()).find(x => x != null && x.VOCAL.length > 0)?.VOCAL[0]?.channel.id;
      const streamKey = `call:${channelId}:1`;
      
      let fn = async () => {
        info(`Completing quest ${questName}`);
        
        while (true) {
          const res = await api.post({url: `/quests/${quest.id}/heartbeat`, body: {stream_key: streamKey, terminal: false}});
          const progress = res.body.progress.PLAY_ACTIVITY.value || 0;
          const progText = progressBar(progress, secondsNeeded);
          const percent = Math.round((progress / secondsNeeded) * 100);
          const color = percent >= 90 ? '#00ff9d' : percent >= 50 ? '#ffcc00' : '#4da6ff';
          log(`Progress: ${progText}`, color);
          
          await new Promise(resolve => setTimeout(resolve, 20 * 1000));
          
          if (progress >= secondsNeeded) {
            await api.post({url: `/quests/${quest.id}/heartbeat`, body: {stream_key: streamKey, terminal: true}});
            break;
          }
        }
        
        success(`Quest completed: ${questName} üéâ`);
        doJob();
      };
      fn();
    }
  };
  doJob();
}

```

</details>


## 8. –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –æ—Ç–∫—Ä—ã—Ç—É—é –∫–æ–Ω—Å–æ–ª—å –≤ `Discord PTB` 

- –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –≤–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç –∏–ª–∏ —Å–∫—Ä–∏–ø—Ç –∫–æ–Ω—Å–æ–ª—å –≤—ã–¥–∞—Å—Ç –ø—Ä–∏–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ `Warning:`

```info
Warning: Don‚Äôt paste code into the DevTools Console that you don‚Äôt understand or haven‚Äôt reviewed yourself. This could allow attackers to steal your identity or take control of your computer. Please type ‚Äòallow pasting‚Äô below and hit Enter to allow pasting.
```

<p align="center">
  <img src="./media/1-Console-Warning.png" alt="Console-Warning" width="500">
</p>

- –≤–≤–æ–¥–∏–º —Ç–µ–∫—Å—Ç

```bash
allow pasting
```
<p align="center">
  <img src="./media/2-Console-Warning.png" alt="Console-Warning" width="500">
</p>

- –ø–æ—Å–ª–µ —á–µ–≥–æ –≤–≤–æ–¥–∏–º –Ω–∞—à —Å–∫—Ä–∏–ø—Ç –∏ –Ω–∞–∂–∏–º–∞–µ–º `Enter`

<details>
    <summary> ‚öôÔ∏è –†–∞–∑–≤–µ—Ä–Ω–∏—Ç–µ –≤–Ω—É—Ç—Ä–∏ —Å–∫—Ä–∏–ø—Ç: </summary>

```js
delete window.$;
let wpRequire = webpackChunkdiscord_app.push([[Symbol()], {}, r => r]);
webpackChunkdiscord_app.pop();

let ApplicationStreamingStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getStreamerActiveStreamMetadata).exports.Z;
let RunningGameStore = Object.values(wpRequire.c).find(x => x?.exports?.ZP?.getRunningGames).exports.ZP;
let QuestsStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getQuest).exports.Z;
let ChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getAllThreadsForParent).exports.Z;
let GuildChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.ZP?.getSFWDefaultChannel).exports.ZP;
let FluxDispatcher = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.flushWaitQueue).exports.Z;
let api = Object.values(wpRequire.c).find(x => x?.exports?.tn?.get).exports.tn;

let quest = [...QuestsStore.quests.values()].find(x => x.id !== "1248385850622869556" && x.userStatus?.enrolledAt && !x.userStatus?.completedAt && new Date(x.config.expiresAt).getTime() > Date.now())
let isApp = typeof DiscordNative !== "undefined"
if(!quest) {
	console.log("Voc√™ n√£o tem nenhuma miss√£o n√£o conclu√≠da!")
} else {
	const pid = Math.floor(Math.random() * 30000) + 1000
	
	const applicationId = quest.config.application.id
	const applicationName = quest.config.application.name
	const taskName = ["WATCH_VIDEO", "PLAY_ON_DESKTOP", "STREAM_ON_DESKTOP", "PLAY_ACTIVITY", "WATCH_VIDEO_ON_MOBILE"].find(x => quest.config.taskConfigV2.tasks[x] != null)
	const secondsNeeded = quest.config.taskConfigV2.tasks[taskName].target
	let secondsDone = quest.userStatus?.progress?.[taskName]?.value ?? 0

	if(taskName === "WATCH_VIDEO" || taskName === "WATCH_VIDEO_ON_MOBILE") {
		const maxFuture = 10, speed = 7, interval = 1
		const enrolledAt = new Date(quest.userStatus.enrolledAt).getTime()
		let fn = async () => {			
			while(true) {
				const maxAllowed = Math.floor((Date.now() - enrolledAt)/1000) + maxFuture
				const diff = maxAllowed - secondsDone
				const timestamp = secondsDone + speed
				if(diff >= speed) {
					await api.post({url: `/quests/${quest.id}/video-progress`, body: {timestamp: Math.min(secondsNeeded, timestamp + Math.random())}})
					secondsDone = Math.min(secondsNeeded, timestamp)
				}
				
				if(timestamp >= secondsNeeded) {
					break
				}
				await new Promise(resolve => setTimeout(resolve, interval * 1000))
			}
			console.log("Miss√£o conclu√≠da!")
		}
		fn()
		console.log(`Spoofing video for ${applicationName}.`)
	} else if(taskName === "PLAY_ON_DESKTOP") {
		if(!isApp) {
			console.log("Isso n√£o funciona mais no navegador para miss√µes que n√£o sejam em v√≠deo. Use o aplicativo para desktop para concluir a ", applicationName, "miss√£o!")
		} else {
			api.get({url: `/applications/public?application_ids=${applicationId}`}).then(res => {
				const appData = res.body[0]
				const exeName = appData.executables.find(x => x.os === "win32").name.replace(">","")
				
				const fakeGame = {
					cmdLine: `C:\\Program Files\\${appData.name}\\${exeName}`,
					exeName,
					exePath: `c:/program files/${appData.name.toLowerCase()}/${exeName}`,
					hidden: false,
					isLauncher: false,
					id: applicationId,
					name: appData.name,
					pid: pid,
					pidPath: [pid],
					processName: appData.name,
					start: Date.now(),
				}
				const realGames = RunningGameStore.getRunningGames()
				const fakeGames = [fakeGame]
				const realGetRunningGames = RunningGameStore.getRunningGames
				const realGetGameForPID = RunningGameStore.getGameForPID
				RunningGameStore.getRunningGames = () => fakeGames
				RunningGameStore.getGameForPID = (pid) => fakeGames.find(x => x.pid === pid)
				FluxDispatcher.dispatch({type: "RUNNING_GAMES_CHANGE", removed: realGames, added: [fakeGame], games: fakeGames})
				
				let fn = data => {
					let progress = quest.config.configVersion === 1 ? data.userStatus.streamProgressSeconds : Math.floor(data.userStatus.progress.PLAY_ON_DESKTOP.value)
					console.log(`Progresso da miss√£o: ${progress}/${secondsNeeded}`)
					
					if(progress >= secondsNeeded) {
						console.log("Miss√£o conclu√≠da!")
						
						RunningGameStore.getRunningGames = realGetRunningGames
						RunningGameStore.getGameForPID = realGetGameForPID
						FluxDispatcher.dispatch({type: "RUNNING_GAMES_CHANGE", removed: [fakeGame], added: [], games: []})
						FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn)
					}
				}
				FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn)
				
				console.log(`Seu jogo foi falsificado para ${applicationName}. Aguarde mais ${Math.ceil((secondsNeeded - secondsDone) / 60)} minutos.`)
			})
		}
	} else if(taskName === "STREAM_ON_DESKTOP") {
		if(!isApp) {
			console.log("Isso n√£o funciona mais no navegador para miss√µes que n√£o sejam em v√≠deo. Use o aplicativo de desktop para concluir a", applicationName, "miss√£o!")
		} else {
			let realFunc = ApplicationStreamingStore.getStreamerActiveStreamMetadata
			ApplicationStreamingStore.getStreamerActiveStreamMetadata = () => ({
				id: applicationId,
				pid,
				sourceName: null
			})
			
			let fn = data => {
				let progress = quest.config.configVersion === 1 ? data.userStatus.streamProgressSeconds : Math.floor(data.userStatus.progress.STREAM_ON_DESKTOP.value)
				console.log(`Progresso da miss√£o: ${progress}/${secondsNeeded}`)
				
				if(progress >= secondsNeeded) {
					console.log("Miss√£o conclu√≠da!")
					
					ApplicationStreamingStore.getStreamerActiveStreamMetadata = realFunc
					FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn)
				}
			}
			FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn)
			
			console.log(`Sua transmiss√£o foi falsificada para ${applicationName}. Transmita qualquer janela em vc por mais ${Math.ceil((secondsNeeded - secondsDone) / 60)} minutos.`)
			console.log("Lembre-se de que voc√™ precisa de pelo menos mais uma pessoa no vc!")
		}
	} else if(taskName === "PLAY_ACTIVITY") {
		const channelId = ChannelStore.getSortedPrivateChannels()[0]?.id ?? Object.values(GuildChannelStore.getAllGuilds()).find(x => x != null && x.VOCAL.length > 0).VOCAL[0].channel.id
		const streamKey = `call:${channelId}:1`
		
		let fn = async () => {
			console.log("Concluindo miss√£o", applicationName, "-", quest.config.messages.questName)
			
			while(true) {
				const res = await api.post({url: `/quests/${quest.id}/heartbeat`, body: {stream_key: streamKey, terminal: false}})
				const progress = res.body.progress.PLAY_ACTIVITY.value
				console.log(`Progresso da miss√£o: ${progress}/${secondsNeeded}`)
				
				await new Promise(resolve => setTimeout(resolve, 20 * 1000))
				
				if(progress >= secondsNeeded) {
					await api.post({url: `/quests/${quest.id}/heartbeat`, body: {stream_key: streamKey, terminal: true}})
					break
				}
			}
			
			console.log("Miss√£o conclu√≠da!")
		}
		fn()
	}
}

```

</details>

## 8. –ü–æ—Å–ª–µ —á–µ–≥–æ —Å–∫—Ä–∏–ø—Ç –Ω–∞—á–∏–Ω–∞–µ—Ç —Ä–∞–±–æ—Ç—É –∞ –º—ã –∂–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è

- –ü—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å–∫—Ä–∏–ø—Ç–∞ –≤ –∫–æ–Ω—Å–æ–ª—å –±—É–¥–µ—Ç –≤—ã–≤–æ–¥–∏—Ç—å—Å—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

<p align="center">
  <img src="./media/5-Automatic-Discord-tasks.png" alt="Automatic-Discord-tasks" width="400">
</p>

- –¢–∞–∫ –∂–µ –±—É–¥–µ—Ç –∏–∑–º–µ–Ω—è—Ç—å—Å—è –ø—Ä–æ—Ü–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

<p align="center">
  <img src="./media/8-Automatic-Discord-tasks.png" alt="Automatic-Discord-tasks" width="400">
</p>

- –ü–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—é –Ω–∞–∂–∏–º–∞–µ–º `–ø–æ–ª—É—á–∏—Ç—å –Ω–∞–≥—Ä–∞–¥—É`

<p align="center">
  <img src="./media/9-Automatic-Discord-tasks.png" alt="Automatic-Discord-tasks" width="400">
</p>



<div align="center">
  <img src="./media/image0.gif" alt="SPACER" width="90%">
</div>

